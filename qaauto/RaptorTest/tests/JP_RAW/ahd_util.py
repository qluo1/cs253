# Setup local python path
import config.service.cfg
import logging
import zerorpc
import gevent
import pprint

from conf import settings
from scapy.all import *
from config.service.ahd import *
from utils import SeqNumber
from tests._utils import ahd_qty, ahd_price

log = logging.getLogger(__name__)

DEFAULT_SESSION = 'VS0030'
ahd_service_ = zerorpc.Client(settings.AHD_API_ENDPOINT)

class AHDMessageListener(object):
    def __init__(self):
        ## Listening to AHD message
        self.subscriber_ = zerorpc.Subscriber(methods={'on_packet': self.on_packet})
        self.subscriber_.connect(settings.AHD_PUB_ENDPOINT)
        log.info('Listening to AHD message at endpoint: %s' % settings.AHD_PUB_ENDPOINT)
        
        self.cache_ = {}
        self.sessions_ = []

        self.running_ = True
        self.worker_ = gevent.spawn(self.subscriber_.run)

    def register(self, session, ordid):
        if (session, ordid) not in self.cache_:
            self.cache_[(session, ordid)] = gevent.queue.Queue()

        if session not in self.sessions_:
            self.sessions_.append(session)

    def on_packet(self, packet):
        try:
            assert isinstance(packet, dict)
            ## do nothing if it is outgoing message
            if packet['name'] == 'send_packet':                
                return

            msg_raw = packet['msg']
            msg = ESPCommon(msg_raw)

            ## do nothing if it is heartbeat
            if msg.getfieldval('MsgType') != '50':
                return
            
            order_id = msg.getfieldval('IntProcessing')
            session = msg.getfieldval('VSNum')

            log.debug('received AHD ER: %s, %s' % (order_id, ahd_service_.showPacket2(msg_raw, 'ESPCommon')))

            ## do nothing if session is not regiestered
            if session not in self.sessions_:
                return
            if (session, order_id) not in self.cache_:
                return
            
            if (session, order_id) not in self.cache_:
                self.cache_[(session, order_id)] = gevent.queue.Queue()

            self.cache_[(session, order_id)].put(msg)

        except Exception, e:
            log.exception(e)

    def get_ahd_message(self, session = DEFAULT_SESSION, order_id = None, expected_num_msg = 1):
        assert session is not None
        assert order_id is not None
        assert expected_num_msg > 0
        ret = []

        for i in range(expected_num_msg):
            try:
                msg = self.cache_[(session, order_id)].get(timeout = 10)
                ret.append(msg)
            except Exception, e:
                log.exception(e)
                raise Exception('AHD Message not received for order_id: %s' % order_id)
        return ret

    def flush_cache(self):
        self.cache = {}

    def stop(self):
        log.info('Stopping AHD message listener...')
        if self.running_:
            self.subscriber_.close()
        self.running_ == False


class AHDOrder(object):
    def __init__(self, session, verifier, ahd_listener, dc_listener, csv_exporter, zcmd, reporter):
        self.ahd = ahd_listener
        self.dc = dc_listener
        self.zcmd = zcmd
        self.csv_exporter_ = csv_exporter
       
        self.session_ = session
        self.verifier_ = verifier
        self.reporter_ = reporter
        self.seqNum_ = SeqNumber(settings.TMP_DIR, session)

        self.cache_ = {}
##TODO: how to deal with dropcopy session?


    def sendNewOrder(self, symbol, qty, side='3', price=None, execCond='0', shortSellFlag='0', propBrokerageClass='0', cashMarginCode='0', stabArbCode='0', ordAttrClass='1', suppMemberClass='0', exchClass='1', mktClass='11', vsNum=None, ordid=None, optional='0000'):
        """ Send a new order message to arhd line

            A wrapper based on Fusion script's API (config/service/ahd_client.py)
            The order id is generated by seq_number
        """
        ## Generate next ordid
        ordid = self._get_next_order_id()

        self._register(ordid)

        ret = ahd_service_.sendNewOrder(symbol, qty, side, price, execCond, shortSellFlag, propBrokerageClass, cashMarginCode, stabArbCode, ordAttrClass, suppMemberClass, exchClass, mktClass, vsNum, ordid, optional)

        log.info(ahd_service_.showPacket2(ret, 'OrderCommon'))

        ret = OrderCommon(ret)
        self.cache_[ordid] = ret
        return ordid


    def sendMod(self, ordid, symbol, qty=None, price=None, execCond = None, exchClass='1', mktClass='11', dataClassCode=None, vsNum=None, optional=None):
        """ Send a modification message to arhd line

            A wrapper based on Fusion script's API (config/service/ahd_client.py)
        """

        self._register(ordid)

        ret = ahd_service_.sendMod(ordid, symbol, qty, price, execCond, exchClass, mktClass, dataClassCode, vsNum, optional)

        log.info(ahd_service_.showPacket2(ret, 'OrderCommon'))

        ret = OrderCommon(ret)
        self.cache_[ordid] = ret
        return ordid

    def sendCancel(self, ordid, symbol=None, exchClass='1', mktClass='11', dataClassCode=None, vsNum=None):
        """ Send a cancel message to arhd line

            A wrapper based on Fusion script's API (config/service/ahd_client.py)
        """
        self._register(ordid)

        ret = ahd_service_.sendCancel(ordid, symbol, exchClass, mktClass, dataClassCode, vsNum)

        log.info(ahd_service_.showPacket2(ret, 'OrderCommon'))

        ret = OrderCommon(ret)
        self.cache_[ordid] = ret
        return ordid

    ## For compatibility with Fusion script
#    def expect(self, ordid, expected_msg_type, expected_reason_code, testcase_name, serial_code):
#        if self.csv_exporter_ is None:
#            raise Exception('Have to provide csv_exporter when calling expect!')
#        last_req = self.getLastRequest()
#        last_req_pretty = ahd_service_.showPacket2(str(last_req), last_req.name)
#        recv_msg = self.ahd.get_ahd_message(order_id = ordid, expected_num_msg = 1)[0]
#        recv_msg_pretty = ahd_service_.showPacket2(str(recv_msg), recv_msg.name)
#        ## Last_req is str format, recv_msg is pkt format
#        self.csv_exporter_.expect(last_req, last_req_pretty, recv_msg, recv_msg_pretty, expected_msg_type, expected_reason_code, testcase_name, serial_code)

    def expect(self, ordid, expected_msg, teststep_name):
        """ Compare arhd message received with expected message dict

            Arguments:
            ordid -- The order id we are expecting to receive
            expected_msg -- A dictionary contains the fields we want to verify against received message
            teststep_name -- A description of this test step (Will be written in test report)
 
            Generally it performs the following actions:
            1. Wait until it get a message from the arhd line with given ordid (Or it throws time out exception if message not received with in 10 seconds)
            2. Verify the expected message against received message
            3. Write the verification result into CSV file and HTML report page.

            Calling this API will add the verification result into reporting page.
            If just want to receive a message but not verifying it (do not want to make it occur in report), please instead use ahd_service.ahd.get_ahd_message() API
        """
        ## Get our previous requesting message
        last_req = self._getLastRequest(ordid)
        last_req_pretty = ahd_service_.showPacket2(str(last_req), last_req.name)

        ## Wait until we receive a message from arhd line
        recv_msg = self.ahd.get_ahd_message(order_id = ordid, expected_num_msg = 1)[0]
        recv_msg_pretty = ahd_service_.showPacket2(str(recv_msg), recv_msg.name)

        log.info('AHD ER: %s, %s' % (ordid, recv_msg_pretty))

        ## Verification
        result, error_msg  = self.verifier_.verify(recv_msg, expected_msg)

        ## Reporting -- into both CSV file and HTML page
        passes = 'OK' if result else 'FAIL'
        expected_msg_pretty = pprint.pformat(expected_msg)

        line = '%s,\"%s\",\"%s\",\"%s\",%s,\"%s\",\"%s\",\"%s\"\n' % \
               (teststep_name, last_req_pretty, recv_msg_pretty, expected_msg_pretty, passes, str(last_req), str(recv_msg), error_msg)

        self.reporter_(line)
        self.csv_exporter_.write(line)

    def expect_field(self, received_field, expected_field, field_name, teststep_name):
        """ Compare a certain field with expected field

            Arguments:
            received_field -- The field we received
            expected_field -- The field we are expecting
            field_name -- Description of the field we are verifying, this will present in report
            teststep_name -- Description of the current test step, this will present in report

            This API will verify the received_field against expected_field and write the verification result into html file (but not csv file)
        """
        ## Verification
        result, error_msg = self.verifier_.verify_field(received_field, expected_field)

        ## Reporting -- only into HTML page
        passes = 'OK' if result else 'FAIL'
        line = '%s,\"%s\",\"%s\",\"%s\",%s,\"%s\",\"%s\",\"%s\"\n' % \
               (teststep_name, '', field_name + ' is ' + str(received_field), field_name + ' is ' + str(expected_field), passes, '', '', error_msg)

        self.reporter_(line)


    def _getLastRequest(self, ordid):
        ## Get the last request message for given ordid
        if ordid not in self.cache_:
            raise Exception('Can not find request for ordid: %s' % ordid)
        return self.cache_[ordid]

    def _register(self, ordid):
        ## Register the ordid against arhd and dc line
        self.dc.register(ordid)
        self.ahd.register(self.session_, ordid)

    def _get_next_order_id(self):
        ## Guarantee the length of order_id (IntProcessing) is 20
        vsNum = self.session_ 
        prefix = settings.CFG['prefix']
        seq_length = 20 - len(prefix) - len(vsNum)

        seq_num = self.seqNum_.next
        seq_num = str(seq_num).zfill(seq_length)
        return prefix + seq_num + vsNum

class AHDMessageVerifier(object):
    def __init__(self, expect):
        self.expect = expect

    def verify(self, received_msg, expected_msg):
        assert type(expected_msg) == dict
        fields = self.get_default_fields(received_msg)
        fields.update(expected_msg)
        result = True
        error_msg = ''
        for field in fields:
            f = fields[field]
            if f == '*':
                msg = 'field %s does not exist in received msg' % field
                r = self.expect(hasattr(received_msg, field), msg)
                if not r:
                    if error_msg != '':
                        error_msg += '\n'
                    error_msg += msg
            else:
                if field in ['Price']:
                    f = ahd_price(f)
                elif field in ['Qty', 'PartExecQty', 'ValidOrderQty']:
                    f = ahd_qty(f)
                msg = 'field %s received: %s != expected %s' % (field, received_msg.getfieldval(field), f)
                r = self.expect(received_msg.getfieldval(field) == f, msg)
                if not r:
                    if error_msg != '':
                        error_msg += '\n'
                    error_msg += msg
            result = result and r
        return result, error_msg

    def verify_field(self, received_field, expected_field):
        msg = 'received field is not equal to expected field'
        result = self.expect(received_field == expected_field, msg)
        if not result:
            return result, msg
        else:
            return result, ''

    def get_default_fields(self, pkt):
        ## To verify all fields in received msg
        ## These are default fields in ESPCommon layer
        default_fields = {
            'MsgLen': '*',
            'MsgType': '*',
            'MsgSeqNum': '*',
            'ResendFlag': '*',
            'ParticipantCode': '*',
            'VSNum': '*',
            'ARMSN': '*',
            'SAMSN': '*',
            'DataLen': '*',
            'NumDataTrans': '*',
            'TransDate': '*',
            'TransTime': '*',
            'Reserved': ' '
        }
        if OrderCommon in pkt:
            additional_fields = {

            }
            default_fields.update(additional_fields)
        elif NoticeCommon in pkt:
            additional_fields = {

            }
            default_fields.update(additional_fields)
        return default_fields
